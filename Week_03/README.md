没有跑的慢的程序，只有相对挫的思路
=================================

本周我最大的收获主要分为两块：<br>
>第一块是“部分战胜了对树DFS递归”的心理阴影，但感觉熟练程度需要提高。<br>
>第二块是真心被leetcode国际站“光头哥”的技术魅力所折服。感触来源自练习的两道题：<br>
>>1）二叉树的最近公共祖先<br>
>>2）根据前序遍历、中序遍历构造二叉树<br><br>
当我“磕磕绊绊地啃完官方题解”，成功提交自己的代码后，突然发现国际站中“光头哥”对于这两道题的精辟解答：<br>
>第1）道题首先被他的解答标题所吸引“各类语言的4行代码题解”。带着好奇，阅读许久，被他的精炼代码所折服。再结合后来偶然机会发现国内站的关于这个方案的精解，终于对这个方案理解透彻。并且首次在leetcode上面留下了我的首个评论踪迹^V^。<br><br>
>第2）道题他的解答在国际站的投票不是第一，但依旧被他的标题所吸引“一种不适用哈希映射、时间复杂度依旧是O(n)的解答方法”。（因为国内站官方题解的递归思路借助“哈希映射加快在中序遍历数组中查找根节点索引”，采用以“空间换时间”的思路加快程序执行速度。）<br><br>
经过多次阅读“光头哥”解题思路，结合下面一位“同仁的JAVA题解”，自己在草稿纸画递归状态图（没办法实在看不懂，只能老老实实画这个递归状态图^_^）。<br>
终于明白了其解题思路不是通过分割前序遍历、中序遍历数组，而是在前序遍历数组、中序遍历数组中引入两个遍历索引，一旦在中序遍历数组中发现根节点，就停止递归，再次在国内站提交这个题解后，执行速度击败了99.98%JAVA用户，内存击败了80%的JAVA用户，几乎是压倒性胜利。。。<br><br>
这次的经历让我有两点感触：<br>
>1）评论标题必须“点题”，切中要点的描述解题思路标题，更能吸引读者阅读。<br>
>2）没有跑的慢的程序，只有相对挫的思路。<br>
